---
layout: post
title: "C++ 理解函数声明"
description: "理解函数声明"
category: cpp
tags: [c++]
---
{% include JB/setup %}







2.1 理解函数声明

写一个c语句，当计算机启动时，硬件将调用首地址为0位置的子例程。 

`(*(void(*)())0)();`

---------------------------
任何C变量的声明都有两部分组成：类型以及一组类似表达式的声明符（declarator）, 声明符从表面上看与表达式有些类似，对它求值应该返回一个声明中给定类型的结果。

最简单的声明符就是单个变量：

`float f,g;`

这个声明 的含义是：当对其求值时，表达式f和g的类型为浮点数类型。

因为声明符与表达式的相似，所以可以在声明符中任意使用括号：

`float ((f));`

这个声明 的含义是：当对其求值时，((f))的类型为浮点类型，由此可以推知，f也是浮点类型。

同样的逻辑也适用于函数和指针类型的声明：

`float ff();`

这个声明的含义是：表达式ff()求值结果是一个浮点数，也就是说ff是一个返回值为浮点类型的函数。

类似的：

`float *pf;`

这个声明的含义是`*pf`是一个浮点数，也就是说，pf是一个指向浮点数的指针。

以上形式在声明中可以组合起来，就像在表达式中进行组合一样：

`float *g(), (*h) ();`

表示`*g()与(*h)()`是浮点表达式。因为()的优先级高于\*， `*g()也就是 *(g()): g `是一个函数，该函数的返回值类型为指向浮点数的指针。同理，可以得出h是一个函数指针，h所指向函数的返回值为浮点类型。

知道了如何声明一个给定类型的变量，那么改类型的 类型转换符 就很容易得到，只需要把声明中的变量名和声明末尾的分号去掉，再将剩余的部分用一个括号整个“封装“起来即可，例如：下面的声明：

`float (*h) ();`

表示h是一个指向返回值为浮点类型的函数指针，因此

`(float (*)())`

表示一个”指向返回值为浮点类型的函数的指针“的 类型转换符 .

现在可以分两步来分析表达式 `(*(void(*)())0)().`


第一步，假定变量fp是一个函数指针，则调用fp所指向的函数：

`(*fp)();`

因为fp是一个函数指针，那么\*fp就是该指针指向的函数，所以`(*fp)()`就是调用该函数的方式。  ANSIC 标准允许将上式简写为fp()，但是一定要记住这种写法知识一种简写形式。

如果\*fp两侧没有括号，那么`*fp()`实际上与`*(fp())`的含义完全一致，ANSIC把它作为`*((*fp)())`的简写形式。

第二步：
现在，剩下的问题就知识找到一个恰当的表达式来代替fp。 如果C编译器能理解我们大脑中对于类型的认识，那么我们可以这样写：

`(*0) ();`

上式并不能生效，因为运算符\*必须要一个指针来做操作数，而且，这个指针还应该是一个车函数指针，这样经运算符\*作用后的囧过才能作为函数被调用。因此，在上式中必须对0作类型转换，转换后的类型
可以大致描述为： "指向返回值为void类型的函数的指针".

如果fp是一个指向值为void类型的函数的指针，那么`(*fp)()的值为void`， fp的声明如下：

`void (*fp) ();`

因此，我们可以用下式来完成调用存储位置为0的子例程：

`void (*fp) ();            //假设fp的默认初始化为0`

`(*fp)();`

这种写法的代价是多声明一个 “哑” 变量。

一旦知道如何声明一个变量，也就自然知道如何对一个常数进行类型转换，将其转换为该变量的类型，只需要在变量声明中将变量名去掉即可。
因此将常数0转型为“指向返回值为void的函数的指针”类型， 

`(void (*) () ) 0`


因此我们可以用 `(void(*)())0` 来代替fp，从而得到：

`( *(void(*)())0 ) ();`


使用typedef声明

```
typedef void (*funcptr) ();
(*(funcptr)0) ();
```



